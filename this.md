# Понимание ключевого слова `this` в javascript

В этой статье мы узнаем о ключевом слове `this` в JS и о том, какое значение оно имеет при различных сценариях.
Лучший способ понять содержание этой статьи - это выполнить фрагмент кода в консоли вашего браузера.
Выполните следующие шаги, чтобы запустить консоль в браузере Chrome:

* Откройте новую вкладку в браузере
* Кликните правой кнопкой мыша на странице, и выберете “inspect element” в контекстном меню
* Перейти в панель Консоль
* Начните выполнять javascript код

Объекты являются основными строительными блоками в JS.
В JS доступен один специальный объект - `this`.
Вы можете получить его значение в каждой строке выполняемого кода на JS.
Его значение зависит от того, как выполняется код.

Прежде чем начать, нам нужно немного понять среду выполнения JavaScript и то, как выполняется код на JavaScript.

## Интерпретатор JavaScript и контекст выполнения

JavaScript - это язык сценариев, что означает, что при выполнении кода не требуется никаких этапов компиляции.
Интерпретатор читает код и выполняет его построчно.
Среда (или область), в которой выполняется строка, называется контекстом выполнения.
Среда выполнения JavaScript поддерживает стек этих контекстов выполнения, и контекст выполнения,
представленный в верхней части этого стека, является тем, который выполняется в данный момент.
Объект, к которому это относится, изменяется каждый раз, когда изменяется контекст выполнения.

## `this` относится к глобальному объекту
По умолчанию контекст выполнения является глобальным - это означает, 
что если код выполняется как часть простого вызова функции, то он относится к глобальному объекту.
Объект `window` является глобальным объектом в для браузера.
В среде NodeJS это будет специальный объект, называемый `global`.

Пример:
```js
function foo () {
	console.log("Простой вызов функции");
	console.log(this === window); 
}

foo();	// Напечатает true в консоль
console.log(this === window) // Напечатает true в консоль
```

## Выражение немедленного вызова функции (IIFE)

```js
(function(){
	console.log("Анонимный вызов функции");
	console.log(this === window);
})();
// Напечатает true в консоль
```
Если для функции включен строгий режим, то значение `this` будет помечено как `undefined`, как в строгом режиме.
Глобальный объект ссылается на `undefined` вместо объекта `window`.

Пример:
```js

function foo () {
	'use strict';
	console.log("Simple function call")
	console.log(this === window); 
}

foo(); // Напечатает false в консоль, так как в «строгом режиме» значение «this» в глобальном контексте выполнения не определено.
```
`foo();` напечатает `false` в консоль,  поскольку в строгом режиме значение этого параметра в контексте глобального выполнения не определено.

## `this` относится к новому экземпляру
Когда функция вызывается с ключевым словом `new`, то функция называется конструктором функции и возвращает новый экземпляр.
В таких случаях значение `this` относится к вновь созданному экземпляру.

Пример:

```js
function Person(fn, ln) {
	this.first_name = fn;
	this.last_name = ln;

	this.displayName = function() {
		console.log(`Name: ${this.first_name} ${this.last_name}`);
	}
}

let person = new Person("John", "Reed");
person.displayName();  // Напечатает Name: John Reed
let person2 = new Person("Paul", "Adams");
person2.displayName();  // Напечатает Name: Paul Adams
```
В случае person.displayName(), `this` относится к новому экземпляру person, 
а в случае person2.displayName() `this` относится к person2 (который отличается от Person).

## “this” относится к вызывающему объекту (родительский объект)
В JavaScript свойством объекта может быть метод или примитивное значение. 
Когда вызывается метод объекта, то `this` относится к объекту, который содержит вызываемый метод.
В этом примере мы будем использовать метод `foo`, определенный в первом примере.

```js
function foo () {
	'use strict';
	console.log("Простой вызов функции")
	console.log(this === window); 
}

let user = {
	count: 10,
	foo: foo,
	foo1: function() {
		console.log(this === window);
	}
}

user.foo()  // Напечатает false потому, что сейчас “this” ссылается на объект user вместо глобального объекта.
let fun1 = user.foo1;
fun1() // Напечатает true так как метод вызывается как простая функция
user.foo1()  // Напечатает false в консоль так, как foo1 вызывается как метод объекта 
```

`user.foo()` выводит `false`, потому что теперь `this` относится к объекту user, а не к глобальному объекту.

С приведенным выше примером ясно, как значение этого может быть запутанным в некоторых случаях.
Определение функции `foo1` такое же, но когда оно вызывается как простой вызов функции, то `this` относится к глобальному объекту. 
И когда то же самое определение вызывается как метод объекта, то `this` относится к родительскому объекту. 
Таким образом, значение `this` зависит от того, как вызывается метод.

## "this" в методах call и apply

Функция в JavaScript также является особым типом объекта. 
Каждая функция имеет методы `call`, `bind` и `apply`. 
Эти методы могут использоваться для установки пользовательского значения `this` в контексте выполнения функции.

Мы собираемся использовать второй пример, определенный выше, чтобы объяснить использование `call`:

```js
function Person(fn, ln) {
	this.first_name = fn;
	this.last_name = ln;

	this.displayName = function() {
		console.log(`Name: ${this.first_name} ${this.last_name}`);
	}
}

let person = new Person("John", "Reed");
person.displayName(); // Напечатает Name: John Reed
let person2 = new Person("Paul", "Adams");
person2.displayName(); // Напечатает Name: Paul Adams

person.displayName.call(person2); // Здесь мы устанавливаем значение `this` объекта person2
// Напечатает Name: Paul Adams
```
Единственная разница между методами `call` и `apply` заключается в способе передачи аргумента.
В случае `apply` второй аргумент является массивом аргументов, тогда как в случае метода `call` аргументы передаются индивидуально.

## “this” с методом bind

Метод `bind` возвращает новый метод со ссылкой на первый переданный аргумент. 
Мы будем использовать приведенный выше пример для объяснения метода `bind`.

```js
function Person(fn, ln) {
	this.first_name = fn;
	this.last_name = ln;

	this.displayName = function() {
		console.log(`Name: ${this.first_name} ${this.last_name}`);
	}
}

let person = new Person("John", "Reed");
person.displayName(); // Напечатает Name: John Reed
let person2 = new Person("Paul", "Adams");
person2.displayName(); // Напечатает Name: Paul Adams

let person2Display = person.displayName.bind(person2);  // Создает новую функцию со значением «this» равным объекту person2
person2Display(); // Напечатает Name: Paul Adams
```

## “this” в стрелочных функциях

В рамках ES6 был представлен новый способ определения функции.

```js
let displayName = (fn, ln) => {
  console.log(Name: ${fn} ${ln});
};
```
Когда используется стрелочная функция, для `this` не создается нового значения.
`this` продолжает ссылаться на тот же объект, на который ссылается вне функции.

Давайте рассмотрим еще несколько примеров, чтобы проверить наши знания о `this`.

```js
function multiply(p, q, callback) {
	callback(p * q);
}

let user = {
	a: 2,
	b:3,
	findMultiply: function() {
		multiply(this.a, this.b, function(total) {
			console.log(total);
			console.log(this === window);
		})
	}
}

user.findMultiply();
// Напечатает 6
// Напечатает true
```
Поскольку `callback` вызывается как простой вызов функции внутри функции `multiply`, `this` относится к глобальному объекту `window` в контексте выполнения метода `callback`-a.


```js
var count = 5;
function test () {
	console.log(this.count === 5);
}

test() // Напечатает true так как объявление переменной «count» произошло в глобальном контексте выполнения, так «count» станет частью глобального объекта.
```

`test()` печатает `true`, так как объявление переменной `count` произошло в глобальном контексте выполнения, поэтому `count` станет частью глобального объекта.

## Итог

Так что теперь вы можете выяснить значение `this`, следуя этим простым правилам:
* По умолчанию `this` относится к глобальному объекту, который является `global` в случае NodeJS, и к объекту `window` в случае браузера
* Когда метод вызывается как свойство объекта, `this` относится к родительскому объекту.
* Когда функция вызывается с оператором `new`, `this` относится к созданному экземпляру.
* Когда функция вызывается с использованием методов `call` и `apply`, `this` относится к значению, переданному в качестве первого аргумента

Как вы видели выше, значение `this` может иногда сбивать с толку, но приведенные выше правила могут помочь вам понять значение `this`.

