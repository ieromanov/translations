# Обновление пользовательского интерфейса: сравнение значений vs отслеживания мутаций

Я видел этот твит от Дана Абрамова, освещающий подходы React по сравнению с Vue:

Как автор библиотеки, я исследовал реализацию управления состояниями приложений с точки зрения сравнения значений и отслеживания мутаций. 
В этой статье я объясню, как работают эти два подхода и почему я лично считаю, 
что один лучше, чем другой, для синхронизации пользовательских интерфейсов с состоянием вашего приложения.

## Предисловие

В этой статье мы собираемся сравнить, как два разных подхода к обнаружению изменений состояния влияют на то,
как вы структурируете это состояние, как вы пишете логику для изменения этого состояния 
и, в конечном счете, как это влияет на производительность пользовательского интерфейса.

После прочтения важно помнить, что immutability (сравнение значений) и proxy (отслеживание мутаций) - 
это инструменты, которые можно использовать для решения множества различных задач в различных средах. 
В этой статье мы обсуждаем сравнение значений и отслеживание мутаций для решения проблемы 
обновления пользовательского интерфейса при изменении состояния. 
Также обратите внимание, что когда я говорю «обновление пользовательского интерфейса», 
я не имею в виду касаться DOM. Я имею в виду работу, выполняемую компонентом, чтобы выяснить, нужно ли и что обновлять.
Я буду использовать React в примерах, но вам не нужно ничего знать об этом, чтобы извлечь пользу из этой статьи.

## Обяснение сравнения значений

Я помню, что immutability(неизменность) была сложным вопросом, когда я впервые столкнулся с ней. 
И даже когда я понял, как он работает, я все еще не понимал, для чего он используется. 
Чтобы лучше объяснить immutability, я сначала объясню, как работает сравнение значений, 
а затем как immutability делает это возможным:

Представьте себе простой компонент:

```js
function User ({ user }) {
  return (
    <div>
      <div>Name: {user.name}</div>
      <div>Age: {user.age}</div>
    </div>
  )
}
```
Этот компонент получает состояние пользователя и отображает имя и возраст этого пользователя. 
Это означает, что всякий раз, когда меняется имя или возраст, нам нужен этот компонент для обновления. 
Мы могли бы решить это без immutability. Мы могли бы явно проверить, изменились ли имя и / или возраст:

```js
class User extends React.Component {
  shouldComponentUpdate (nextProps) {
    const currentUser = this.props.user
    const nextUser = nextProps.user

    return currentUser.name !== nextUser.name || currentUser.age !== nextUser.age
  }
  render () {
    const { user } = this.props

    return (
      <div>
        <div>Name: {user.name}</div>
        <div>Age: {user.age}</div>
      </div>
    )  
  }
}
```

Но ручная оптимизация всех таких компонентов была бы утомительной и хрупкой. 
По мере увеличения сложности становится все труднее отлаживать, когда компонент обновляется, 
когда он не должен, и когда он не обновляется, когда он должен.


Если бы наш пользователь был неизменным, нам больше не пришлось бы проверять имя и возраст. 
Было бы достаточно проверить, изменился ли сам пользователь. 
Давайте посмотрим, как мы могли бы обновить возраст, используя изменчивый и неизменный подход:

```js
const user = {
  name: 'Bob',
  age: 40
}

// Изменчивый подход
user.age = 45

// Неизменчивый подход
const updatedUser = Object.assign({}, user, {
  age: 45
})
```
Если бы мы использовали изменчивый подход, сам пользователь не изменился бы, только свойство age. 
С неизменяемостью мы также создаем новый объект пользователя. 
И это неизменность в двух словах. 
Говоря прямо, всякий раз, когда изменяются свойства объектов или массивов, 
изменяются также все прямые родительские объекты и массивы.

В нашем компоненте теперь мы можем убедиться, что он обновляется, сравнивая только старое значение пользователя с новым:

```js
class User extends React.Component {
  shouldComponentUpdate (nextProps) {
    return this.props.user !== nextProps.user
  }
  render () {
    const { user } = this.props

    return (
      <div>
        <div>Name: {user.name}</div>
        <div>Age: {user.age}</div>
      </div>
    )  
  }
}
```
В React нет логики для оптимизации обновлений компонентов, в отличие от Vue. 
Это дает вам ловушку жизненного цикла shouldComponentUpdate для сравнения значений. 
В сочетании с неизменяемостью это простой и эффективный подход для определения необходимости 
обновления пользовательского интерфейса.

Прежде чем мы начнем говорить о преимуществах и проблемах, давайте рассмотрим другой подход.

## Объяснение мутаций

Радикально другой подход к одной и той же задаче позволяет разработчику просто изменять состояние в обычном режиме, 
а не отслеживать то, что изменяется. Используя новую функцию Proxy в JavaScript, 
мы отслеживаем, к какому состоянию обращается компонент и где происходят мутации. 
Сравнивая эти две части информации, мы знаем, какие компоненты должны обновляться и какие мутации должны обновляться.

В отличие от сравнения значений, отслеживание мутаций, возможно, более сложно реализовать. 
Тем не менее, сама реализация скрыта от разработчика, в отличие от сравнения значений, где вам, вероятно, 
придется сравнивать значения вручную, чтобы оптимизировать обновления.

На примере React нам нужно добавить обертку для наших компонентов, которая хорошо показывает, 
как она на самом деле работает:

```js
const User = trackStateAccess(function User ({ user }) {
  return (
    <div>
      <div>Name: {user.name}</div>
      <div>Age: {user.age}</div>
    </div>
  )
})
```

Наш пользовательский компонент обернут логикой, которая будет следить за доступом к состоянию. 
Когда компонент рендерится, мы получаем доступ к двум различным свойствам пользователя, имени и возрасту, 
и сохраняется оборткой `trackStateAccess`.

Когда пользователь определен, мы делаем то же самое, но только для отслеживания мутаций:

```js
const user = trackMutations({
  name: 'Bob',
  age: 40
})

user.age = 45
```

Теперь имеем доступ к отслеживанию мутации и имеем возможность выяснить, какие мутации влияют на какие компоненты. 
Если компонент зависит от user.name и мы делаем мутацию на user.name, они совпадают.

Теперь, когда у нас есть представление о том, как работают два разных подхода, мы можем их сравнить.

## Структура состояния

**Сравнение значений** требует, чтобы вы знали, какое состояние вы передаете в свои компоненты. 
Причина в том, что вложенное изменение приведет к изменению всех прямых родительских объектов и массивов. 
Если вы посмотрите на этот пример:

```js
const state = {
  workspace: {
    files: [{
      id: '123',
      content: ''
    }]
  }
}
```
Каждый раз, когда вы изменяете `content` в `file`, обновляется любой компонент, зависящий от workspace, 
workspace.files или workspace.files[0]. Благодаря этому вы быстро познакомитесь с концепцией нормализации состояния. 
Нормализация состояния не является специфической для подхода сравнения значений, 
но в отличие от отслеживания мутаций вы можете столкнуться с проблемами производительности, если их игнорировать. 
В частности, в этом сценарии вы хотели бы изменить структуру на:









