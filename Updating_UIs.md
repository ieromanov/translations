# Обновление пользовательского интерфейса: сравнение значений vs отслеживания мутаций

Я видел этот твит от Дана Абрамова, освещающий подходы React по сравнению с Vue:

Как автор библиотеки, я исследовал реализацию управления состояниями приложений с точки зрения сравнения значений и отслеживания мутаций. В этой статье я объясню, как работают эти два подхода и почему я лично считаю, что один лучше, чем другой, для синхронизации пользовательских интерфейсов с состоянием вашего приложения.

## Предисловие

В этой статье мы собираемся сравнить, как два разных подхода к обнаружению изменений состояния влияют на то, как вы структурируете это состояние, как вы пишете логику для изменения этого состояния и, в конечном счете, как это влияет на производительность пользовательского интерфейса.

После прочтения важно помнить, что immutability (сравнение значений) и proxy (отслеживание мутаций) - это инструменты, которые можно использовать для решения множества различных задач в различных средах. В этой статье мы обсуждаем сравнение значений и отслеживание мутаций для решения проблемы обновления пользовательского интерфейса при изменении состояния. Также обратите внимание, что когда я говорю «обновление пользовательского интерфейса», я не имею в виду касаться DOM. Я имею в виду работу, выполняемую компонентом, чтобы выяснить, нужно ли и что обновлять. Я буду использовать React в примерах, но вам не нужно ничего знать об этом, чтобы извлечь пользу из этой статьи.

## Обяснение сравнения значений

Я помню, что immutability(неизменность) была сложным вопросом, когда я впервые столкнулся с ней. И даже когда я понял, как он работает, я все еще не понимал, для чего он используется. Чтобы лучше объяснить immutability, я сначала объясню, как работает сравнение значений, а затем как immutability делает это возможным:

Представьте себе простой компонент:

```js
function User ({ user }) {
  return (
    <div>
      <div>Name: {user.name}</div>
      <div>Age: {user.age}</div>
    </div>
  )
}
```
Этот компонент получает состояние пользователя и отображает имя и возраст этого пользователя. Это означает, что всякий раз, когда меняется имя или возраст, нам нужен этот компонент для обновления. Мы могли бы решить это без immutability. Мы могли бы явно проверить, изменились ли имя и / или возраст:

```js
class User extends React.Component {
  shouldComponentUpdate (nextProps) {
    const currentUser = this.props.user
    const nextUser = nextProps.user

    return currentUser.name !== nextUser.name || currentUser.age !== nextUser.age
  }
  render () {
    const { user } = this.props

    return (
      <div>
        <div>Name: {user.name}</div>
        <div>Age: {user.age}</div>
      </div>
    )  
  }
}
```

Но ручная оптимизация всех таких компонентов была бы утомительной и хрупкой.  По мере увеличения сложности становится все труднее отлаживать, когда компонент обновляется, когда он не должен, и когда он не обновляется, когда он должен.


Если бы наш пользователь был неизменным, нам больше не пришлось бы проверять имя и возраст. Было бы достаточно проверить, изменился ли сам пользователь. Давайте посмотрим, как мы могли бы обновить возраст, используя изменчивый и неизменный подход:

```js
const user = {
  name: 'Bob',
  age: 40
}

// Изменчивый подход
user.age = 45

// Неизменчивый подход
const updatedUser = Object.assign({}, user, {
  age: 45
})
```
Если бы мы использовали изменчивый подход, сам пользователь не изменился бы, только свойство age. С неизменяемостью мы также создаем новый объект пользователя. И это неизменность в двух словах. Проще говоря, всякий раз, когда изменяются свойства объектов или массивов, изменяются также все прямые родительские объекты и массивы.

В нашем компоненте теперь мы можем убедиться, что он обновляется, сравнивая только старое значение пользователя с новым:

```js
class User extends React.Component {
  shouldComponentUpdate (nextProps) {
    return this.props.user !== nextProps.user
  }
  render () {
    const { user } = this.props

    return (
      <div>
        <div>Name: {user.name}</div>
        <div>Age: {user.age}</div>
      </div>
    )  
  }
}
```
В React нет логики для оптимизации обновлений компонентов, в отличие от Vue. Это дает вам ловушку жизненного цикла shouldComponentUpdate для сравнения значений. В сочетании с неизменяемостью это простой и эффективный подход для определения необходимости обновления пользовательского интерфейса.

Прежде чем мы начнем говорить о преимуществах и проблемах, давайте рассмотрим другой подход.

## Объяснение мутаций

Радикально другой подход к одной и той же задаче позволяет разработчику просто изменять состояние в обычном режиме, а не отслеживать то, что изменяется. Используя новую функцию Proxy в JavaScript, мы отслеживаем, к какому состоянию обращается компонент и где происходят мутации. Сравнивая эти две части информации, мы знаем, какие компоненты должны обновляться и какие мутации должны обновляться.

В отличие от сравнения значений, отслеживание мутаций, возможно, более сложно реализовать. Тем не менее, сама реализация скрыта от разработчика, в отличие от сравнения значений, где вам, вероятно, придется сравнивать значения вручную, чтобы оптимизировать обновления.

На примере React нам нужно добавить обертку для наших компонентов, которая хорошо показывает, как она на самом деле работает:

```js
const User = trackStateAccess(function User ({ user }) {
  return (
    <div>
      <div>Name: {user.name}</div>
      <div>Age: {user.age}</div>
    </div>
  )
})
```

Наш пользовательский компонент обернут логикой, которая будет следить за доступом к состоянию. Когда компонент рендерится, мы получаем доступ к двум различным свойствам пользователя, имени и возрасту, и сохраняется оборткой `trackStateAccess`.

Когда пользователь определен, мы делаем то же самое, но только для отслеживания мутаций:

```js
const user = trackMutations({
  name: 'Bob',
  age: 40
})

user.age = 45
```

Теперь имеем доступ к отслеживанию мутации и имеем возможность выяснить, какие мутации влияют на какие компоненты. Если компонент зависит от user.name и мы делаем мутацию на user.name, они совпадают.

Теперь, когда у нас есть представление о том, как работают два разных подхода, мы можем их сравнить.

## Структура состояния

**Сравнение значений** требует, чтобы вы знали, какое состояние вы передаете в свои компоненты. Причина в том, что вложенное изменение приведет к изменению всех прямых родительских объектов и массивов. Если вы посмотрите на этот пример:

```js
const state = {
  workspace: {
    files: [{
      id: '123',
      content: ''
    }]
  }
}
```
Каждый раз, когда вы изменяете `content` в `file`, обновляется любой компонент, зависящий от workspace, workspace.files или workspace.files[0]. Благодаря этому вы быстро познакомитесь с концепцией нормализации состояния. Нормализация состояния не является специфической для подхода сравнения значений, но в отличие от отслеживания мутаций вы можете столкнуться с проблемами производительности, если их игнорировать. В частности, в этом сценарии вы хотели бы изменить структуру на:


```js
const state = {
  files: {
    '123': {
      id: '123',
      content: ''
    }
  },
  workspace: {
    files: ['123']
  }
}
```

Это гарантирует, что при изменении `content` в `file` это не влияет `workspace` или массив `files`. Однако нормализация не решает проблему полностью. Любое изменение в файле будет влиять на любой компонент в зависимости от самого файла, даже если его не волновало фактическое изменение свойства. Также вводится необходимость в дополнительной логике, которая хранит идентификаторы массива файлов в словаре.

**Отслеживание мутаций** позволяет структурировать ваше состояние так, как вы хотите. Поскольку он отслеживает точное состояние, используемое в компонентах, не имеет значения, как оно структурировано. В приведенном выше примере изменение содержимого затронет только компоненты, фактически указывающие на workspace.files [0] .content. Это не значит, что вы никогда не будете использовать нормализацию. Например, пользователи могут быть авторами постов, а также авторами комментариев. Чтобы избежать дублирования версий одного пользователя в вашем штате, вы можете использовать нормализацию, чтобы гарантировать, что при смене имени пользователя будут обновляться и публикация, и комментарии. В отличие от неизменяемости вам не нужно делать это по соображениям производительности.

**Вывод** заключается в том, что сравнение значений требует дополнительных действий в определенных приложениях, где вы должны быть осторожны с тем, как структурируется состояние, или у вас возникают проблемы с производительностью. Возможно, вы всегда должны нормализовать свое состояние, хотя это не обязательно нормализуемое состояние, которое вызывает проблему с производительностью. При сравнении значений у вас будут ненужные обновления компонентов, потому что сравнивать каждое отдельное значение слишком утомительно. С отслеживанием мутаций вы доверяете системе. Это освобождает вас от умственной нагрузки в выяснении того, как обновляются компоненты, это просто работает и работает оптимально.

## Синтаксис

Сравнение значений может увеличить количество синтаксиса, необходимого для выражения изменений состояния, поскольку в JavaScript нет встроенной неизменности. Приведенный выше пример можно улучшить с помощью `spread`, а также можно использовать библиотеки, такие как `Immer`, для выражения неизменяемых изменений с помощью традиционного изменяемого API. `Immer` на самом деле использует прокси под капотом. Как автор библиотеки `Immer` может быть интегрирован таким образом, что неизменный характер библиотеки полностью скрыт.
Отслеживание мутаций позволяет вам изменять свое состояние как обычно. Там действительно нет разницы, когда отслеживание интегрировано в библиотеку.
Можно утверждать, что подход отслеживания мутаций поощряет императивный стиль в вашем коде, где неизменность поощряет декларативный функциональный стиль.
Вывод заключается в том, что синтаксис никогда не должен быть решающим фактором. У нас разные мнения о том, как выразить код, и это совершенно нормально!

## Производительность

Сравнение значений очень эффективно в том смысле, что в действительности нет деталей реализации, связанных с компонентами. Мы просто сравниваем значения. При этом любое изменение состояния потребует от каждого отдельного компонента проверки необходимости обновления, если только вы не используете библиотеку с концепцией линз. Если вы определенно говорите о состоянии, необходимом для компонентов, у вас все будет в порядке, но если вы не будете осторожны, это может иметь огромные последствия. Например, изменение текста ввода в сложной форме может легко привести к обновлению всей формы, просто из-за того, как состояние структурировано и используется другими компонентами.
Существует также производительность выполнения изменений состояния. Поскольку все прямые родительские объекты и массивы необходимо заменить, вы будете использовать больше памяти, что чаще всего вызывает сборщик мусора. Неизменяемые библиотеки используют структурное совместное использование для помощи в решении этой проблемы, но в конце концов это будет дорого стоить.
Отслеживание мутаций использует прокси, которые создают дополнительные расходы при доступе к свойствам, например, для отслеживания использования состояния или изменения состояния. Так же, как неизменяемость, есть методы, которые снижают производительность этого отслеживания.
Вывод заключается в том, что производительность невероятно сложно сравнить с двумя очень разными решениями. И есть также три совершенно разные вещи, которые необходимо сравнить:

- Производительность мутаций
- Производительность обнаружения изменений
- Производительность обновлений пользовательского интерфейса

Последний пункт здесь интересен. Если отслеживание мутаций обходится дороже при обнаружении изменений, но имеет меньше обновлений пользовательского интерфейса, как вы это сравниваете? Я не делал никаких тестов для себя и считаю, что это бессмысленно. Это зависит от приложения, и существует множество других не связанных и более важных типов показателей производительности, которые влияют на ваше приложение.

## Главный вывод и итог

Лично я предпочитаю отслеживание мутаций для обработки обновлений пользовательского интерфейса, и вот мои причины:

- Отслеживание мутаций отслеживает, какие именно изменения состояния должны влиять на компонент. Он автоматически оптимизируется в зависимости от того, к какому состоянию вы обращаетесь. Просто зная, что сравнение значений вызывает много ненужных обновлений, я чувствую себя неуправляемым
- Несмотря на то, что я предпочитаю декларативный функциональный подход к программированию, вы всегда будете в некоторой степени писать императивный код. То, что я считаю важным, - это четкое разделение. Ничто не мешает вам абстрагировать императивный код, который вы пишете в мире отслеживания мутаций, в декларативный функциональный мир
- Отслеживание мутаций, возможно, намного проще. И я намеренно использую здесь термин «проще». Наши инструменты могут быть чертовски умны, но публичный API не должно быть
- Отслеживание мутаций может дать больше информации о взаимосвязи между изменениями и о том, на что влияют эти изменения. Это означает, что вы можете получить отчет о вашем текущем состоянии, что реагирует на это состояние и какие изменения были сделаны

В связи с последним пунктом и всей статьей я хочу анонсировать инструмент для авторов библиотек под названием proxy-state-tree, который в настоящее время находится в стадии бета-тестирования. В нем реализована логика, необходимая для отслеживания доступа к состояниям и мутаций, с помощью простого API и отладочной информации. Я построил это с помощью Fabrice (обнимаю Fabrice), чтобы помочь разработчикам перебирать действительно проблемные части создания веб-приложений: «Где и как должно определяться состояние, а где и как должно обновляться состояние?». То, как вы обнаруживаете изменения и обновляете пользовательский интерфейс, должно работать и работать!

В качестве примера использования этого инструмента я построил демонстрационную библиотеку поверх Preact. Это позволяет вам обернуть ваше приложение в провайдера, который получает состояние и действия. Состояние и действия подвергаются воздействию всех подключенных компонентов. В этой простой демонстрации следует обратить внимание на реализацию компонентов и devtools, поскольку она показывает, насколько мощным и гибким является API-интерфейс дерева прокси-состояний. С помощью информации из proxy-state-tree вы можете легко создать опыт отладки, который даст вам глубокое понимание того, что происходит в приложении. В демоверсии обратите внимание на следующее:

Вы получаете список компонентов, активных в пользовательском интерфейсе, и от того, от каких путей состояния они зависят, и сколько раз они отображают

Вы получаете список мутаций, выполненных по каким путям

Действие toggleItemCompleted фактически принимает состояние элемента и изменяет его, но devtools дает вам полный путь к его расположению в дереве состояний.

Попробуйте проверить / снять отметки с элементов и т. Д. И посмотрите, как ведет себя счетчик рендера по сравнению с выполненными мутациями. Вы видите, что между мутациями и компонентами существует взаимно-однозначное отношение. Это происходит автоматически

Вы не можете изменить состояние вне действий, выдается ошибка
